
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateShadowNodeCpp.js
 */

#include "ShadowNodes.h"

#include <react/renderer/core/LayoutConstraints.h>
#include <react/renderer/core/LayoutContext.h>
#include <react/renderer/core/conversions.h>

#include <react/featureflags/ReactNativeFeatureFlags.h>
#include <react/jni/ReadableNativeMap.h>
#include <react/renderer/attributedstring/AttributedStringBox.h>
#include <react/renderer/attributedstring/TextAttributes.h>
#include <react/renderer/components/text/BaseTextShadowNode.h>
#include <react/renderer/core/LayoutConstraints.h>
#include <react/renderer/core/LayoutContext.h>
#include <react/renderer/core/conversions.h>
#include <react/renderer/textlayoutmanager/TextLayoutContext.h>

#include <android/log.h>

#define LOG_TAG "PasteTextInputShadowNode"
#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

namespace facebook::react {

extern const char PasteTextInputComponentName[] = "PasteTextInput";

PasteTextInputShadowNode::PasteTextInputShadowNode(
        const ShadowNode& sourceShadowNode,
        const ShadowNodeFragment& fragment)
        : ConcreteViewShadowNode(sourceShadowNode, fragment) {
    auto& sourcePasteTextInputShadowNode =
        static_cast<const PasteTextInputShadowNode&>(sourceShadowNode);

    if (ReactNativeFeatureFlags::enableCleanTextInputYogaNode()) {
        if (!fragment.children && !fragment.props &&
            sourcePasteTextInputShadowNode.getIsLayoutClean()) {
            // This ParagraphShadowNode was cloned but did not change
            // in a way that affects its layout. Let's mark it clean
            // to stop Yoga from traversing it.
            cleanLayout();
        }
    }
}

void PasteTextInputShadowNode::setContextContainer(
        facebook::react::ContextContainer *contextContainer) {
    ensureUnsealed();
    contextContainer_ = contextContainer;
}

AttributedString PasteTextInputShadowNode::getAttributedString() const {
    // Use BaseTextShadowNode to get attributed string from children
    auto childTextAttributes = TextAttributes::defaultTextAttributes();
//    childTextAttributes.apply(getConcreteProps().textAttributes);

    auto attributedString = AttributedString{};
    auto attachments = BaseTextShadowNode::Attachments{};
    BaseTextShadowNode::buildAttributedString(
            childTextAttributes, *this, attributedString, attachments);

    // BaseTextShadowNode only gets children. We must detect and prepend text
    // value attributes manually.
    if (!getConcreteProps().text.empty()) {
        auto textAttributes = TextAttributes::defaultTextAttributes();
//        textAttributes.apply(getConcreteProps().textAttributes);
        auto fragment = AttributedString::Fragment{};
        fragment.string = getConcreteProps().text;
        fragment.textAttributes = textAttributes;
        // If the TextInput opacity is 0 < n < 1, the opacity of the TextInput and
        // text value's background will stack. This is a hack/workaround to prevent
        // that effect.
        fragment.textAttributes.backgroundColor = clearColor();
        fragment.parentShadowView = ShadowView(*this);
        attributedString.prependFragment(fragment);
    }
    return attributedString;
}

AttributedString PasteTextInputShadowNode::getPlaceholderAttributedString() const {
    // Return placeholder text, since text and children are empty.
    auto textAttributedString = AttributedString{};
    auto fragment = AttributedString::Fragment{};
    fragment.string = getConcreteProps().placeholder;

    LOGI("Trying to get placeholder");

    if (fragment.string.empty()) {
        fragment.string = BaseTextShadowNode::getEmptyPlaceholder();
    }

    auto textAttributes = TextAttributes::defaultTextAttributes();
//    textAttributes.apply(getConcreteProps().textAttributes);

    // If there's no text, it's possible that this Fragment isn't actually
    // appended to the AttributedString (see implementation of appendFragment)
    fragment.textAttributes = textAttributes;
    fragment.parentShadowView = ShadowView(*this);
    textAttributedString.appendFragment(fragment);

    return textAttributedString;
}

AttributedString PasteTextInputShadowNode::getMostRecentAttributedString() const {
    const auto& state = getStateData();

    auto reactTreeAttributedString = getAttributedString();

    // Sometimes the treeAttributedString will only differ from the state
    // not by inherent properties (string or prop attributes), but by the frame of
    // the parent which has changed Thus, we can't directly compare the entire
    // AttributedString
    bool treeAttributedStringChanged =
            !state.reactTreeAttributedString.compareTextAttributesWithoutFrame(
                    reactTreeAttributedString);

    return (
            !treeAttributedStringChanged ? state.attributedString
                                         : reactTreeAttributedString);
}

void PasteTextInputShadowNode::updateStateIfNeeded() {
    ensureUnsealed();

    auto reactTreeAttributedString = getAttributedString();
    const auto& state = getStateData();

    // Tree is often out of sync with the value of the TextInput.
    // This is by design - don't change the value of the TextInput in the State,
    // and therefore in Java, unless the tree itself changes.
    if (state.reactTreeAttributedString == reactTreeAttributedString) {
        LOGI("same");
        return;
    }

    // If props event counter is less than what we already have in state, skip it
    if (getConcreteProps().mostRecentEventCount < state.mostRecentEventCount) {
        LOGI("skip");
        return;
    }

    LOGI("grabbing");

    // Even if we're here and updating state, it may be only to update the layout
    // manager If that is the case, make sure we don't update text: pass in the
    // current attributedString unchanged, and pass in zero for the "event count"
    // so no changes are applied There's no way to prevent a state update from
    // flowing to Java, so we just ensure it's a noop in those cases.
    auto newEventCount =
            state.reactTreeAttributedString.isContentEqual(reactTreeAttributedString)
            ? 0
            : getConcreteProps().mostRecentEventCount;
    auto newAttributedString = getMostRecentAttributedString();

    LOGI("event count: %d", newEventCount);
    LOGI("string: %s", newAttributedString.getString().c_str());

    setStateData(AndroidTextInputState{
            newEventCount,
            newAttributedString,
            reactTreeAttributedString,
            state.paragraphAttributes,
            state.defaultThemePaddingStart,
            state.defaultThemePaddingEnd,
            state.defaultThemePaddingTop,
            state.defaultThemePaddingBottom});
}

Size AndroidTextInputShadowNode::measureContent(
        const LayoutContext& layoutContext,
        const LayoutConstraints& layoutConstraints) const {
    if (getStateData().cachedAttributedStringId != 0) {
        return textLayoutManager_
                ->measureCachedSpannableById(
                        getStateData().cachedAttributedStringId,
                        getConcreteProps().paragraphAttributes,
                        layoutConstraints)
                .size;
    }

    // Layout is called right after measure.
    // Measure is marked as `const`, and `layout` is not; so State can be updated
    // during layout, but not during `measure`. If State is out-of-date in layout,
    // it's too late: measure will have already operated on old State. Thus, we
    // use the same value here that we *will* use in layout to update the state.
    AttributedString attributedString = getMostRecentAttributedString();

    if (attributedString.isEmpty()) {
        LOGI("empty");
        attributedString = getPlaceholderAttributedString();
    } else {
        LOGI("Was not empty");
    }

    if (attributedString.isEmpty() && getStateData().mostRecentEventCount != 0) {
        return {0, 0};
    }

    TextLayoutContext textLayoutContext;
    textLayoutContext.pointScaleFactor = layoutContext.pointScaleFactor;
    return textLayoutManager_
            ->measure(
                    AttributedStringBox{attributedString},
                    getConcreteProps().paragraphAttributes,
                    textLayoutContext,
                    layoutConstraints)
            .size;
}

void PasteTextInputShadowNode::layout(facebook::react::LayoutContext layoutContext) {
    LOGI("layout");
    updateStateIfNeeded();
    ConcreteViewShadowNode::layout(layoutContext);
}

void PasteTextInputShadowNode::setTextLayoutManager(SharedTextLayoutManager textLayoutManager) {
    ensureUnsealed();
    textLayoutManager_ = textLayoutManager;
}


} // namespace facebook::react
